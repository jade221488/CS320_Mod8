# CS320_Mod8

# How can I ensure that my code, program, or software is functional and secure?
I can ensure my code is functional and secure as I implemented automated JUnit5 testing to ensure the majority of my code was being tested and came back as functional and produced the proper outputs I expected. To ensure my code was secure I made sure any libraries used were secure and any ivalid user input was stopped from passing and being stored into the system. Sensitive data was not easily accessible to the user as private variables were used along with accessor and mutator functions.

# How do I interpret user needs and incorporate them into a program?
I interpreted user needs and incorporated them into the program by identifying what needs to be achieved from the program, interpret the needs into actions, and translate them into code. For example, one user need was the Contact object must have a contact ID that cannot be more than ten characters and cannot be blank. The action would be to create a contact ID variable where the user can only enter an input 1-10 characters long and cannot be null. This can be then done by using an if statement that constrains the contact ID variable and if an invalid input is entered the if statement does its job by stopping the program from passing through and storing the invalid input, instead it prompts the user what they entered was invalid with an error message.

# How do I approach designing software?
I approach designing software by mainly following the software development life cycle as it is a good repetitive process that allows room to improve the program. The most important steps is the first part of the life cycle where you collect user needs, interpret them into actions that can be translatable to code. If this part is done incorrectly then the final product of the entire program is going to be incorrect and overall waste more time having to go back and essentially restart. A good way to prevent this is by making sure the research and design process is done correctly and then work in chunks when developing code testing piece by piece. It saved me a lot of time in the end by iterating the developing and testing steps as many times as I needed before deployment.
